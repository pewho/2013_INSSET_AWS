<!doctype html>
<html lang="en">

  <head>
    <meta charset="utf-8">

    <title>Cloud Computing et Architectures Scalables</title>

    <meta name="description" content="">
    <meta name="author" content="Bertrand Tornil">

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <link rel="stylesheet" href="css/reveal.min.css">
    <link rel="stylesheet" href="css/theme/beige.css" id="theme">

    <!-- For syntax highlighting -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

    <style>
.starwars {
  -webkit-transform: rotateX(45deg);
  transform: rotateX(45deg);
}
    </style>

    <!-- If the query includes 'print-pdf', use the PDF print sheet -->
    <script>
      document.write( '<link rel="stylesheet" href="css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );
    </script>

    <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->
  </head>

  <body>

    <div class="reveal">

      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">
        <section>
          <h1>Cloud Computing et Architectures "Scalables"</h1>
          <h3>ou comment utiliser la flexibilité du Cloud pour monter en charge</h3>
          <p>
            <small><a href="http://tornil.me">Bertrand Tornil</a> / <a href="http://twitter.com/bobuss">@bobuss</a></small>
          </p>
        </section>

        <section>
          <section>
            <h2>Montée en charge?</h2>
          </section>
          <section>
            <img width="800" height="583" src="img/wat.jpg" alt="Wat">
          </section>
        </section>

        <section>
          <h2>Imaginons Un Service Web</h2>

            <p>Un client fait une requête HTTP
              <pre><code data-trim contenteditable>
GET /bob http/1.1
Host: www.mon_super_service_web.com
              </code></pre>
            </p>
            <br>
            <p>Le serveur
              <ol>
                <li>... reçoit la réquête...</li>
                <li>... la traite ...</li>
                <li>... et génère une réponse</li>
              </ol>
              <pre><code data-trim contenteditable>
HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 9
Hello bob
              </code></pre>
            </p>
        </section>

        <section>
          <h2>La charge monte</h2>

          <p>Plusieurs clients en même temps (Concurence)</p>

          <img src="img/scalability.jpg">

          <p>Le temps de traitement d'un requête http augmente</p>
        </section>


        <section>
          <h2>Solution 1</h2>
          <p>Investir dans une machine plus puissante</p>

          <img src="general.jpg">
        </section>

        <section>
          <h2>Solution 2</h2>
          <p>Répartir la charge sur plus de machines</p>

* on achète de nouvelles machines (installation, monitoring, test, déploiement)
* OU
* on lance une nouvelle instance sur le Cloud


##Souplesse du Cloud \o/
        </section>

        <section>
          <h2>Fantastic Ordered List</h2>
#Séparation Serveur Web / DB

##Un example avec 2 machines :

* Le serveur web
* La DB

##on améliore les choses, mais ç'est forcément limité

        </section>

        <section data-markdown>
          <script type="text/template">
##Stratégie multi-frontal

on "clone" le serveur web x fois

encore une fois le cloud rend les choses aisées

* AWS = 1 commande = 1 nouvelle instance
* puppet = industrialisation de la configuration
* capistrano = industrialisation du déploiement


et pour répartir les requêtes entre les frontaux

on place un "load balancer" devant
          </script>
        </section>

        <section id="transitions">
          <h2>Transition Styles</h2>
          <p>
            You can select from different transitions, like: <br>
            <a href="?transition=cube#/transitions">Cube</a> -
            <a href="?transition=page#/transitions">Page</a> -
            <a href="?transition=concave#/transitions">Concave</a> -
            <a href="?transition=zoom#/transitions">Zoom</a> -
            <a href="?transition=linear#/transitions">Linear</a> -
            <a href="?transition=fade#/transitions">Fade</a> -
            <a href="?transition=none#/transitions">None</a> -
            <a href="?#/transitions">Default</a>
          </p>
        </section>

        <section id="themes">
#Stratégie multi-frontal

##on "clone" le serveur web x fois

* encore une fois le cloud rend les choses aisées
* * AWS = 1 commande = 1 nouvelle instance
* * puppet = industrialisation de la configuration
* * capistrano = industrialisation du déploiement

## et Pour répartir les requêtes entre les frontaux

* on place un "load balancer" devant
        </section>

        <section>
#Stratégies de "Load balancing"

##round robin

* Chacun son tour

##least connected

* le load-balancer doit pouvoir connaître l'état des connexions des frontaux
* il adapte le flot selon la charge réseau du frontal

##less loaded

* cette fois c'est l'état de charge général du frontal qui est pris en compte

##chaque stratégie a ses avantages / inconvénient

* ELB chez AWS
        </section>

        <section>
#Remarques sur le multi-frontal

## permet de monter pratiquement indéfiniment

* c'est une recette magique, qui a fait ses preuves

## soulève de nouveaux problèmes :

* partage d'information entre frontaux (session)
* déploiement (capistrano règle pas mal de problème)
* prix... à mettre en balance
        </section>

        <section>
#Bottleneck du stockage

## Arrive un moment, ou l'ajout de serveurs Webs cesse de régler le problème de la montée en charge

* le stockage est notre nouveau point de contension

## Première approche : cacher les données

* memcache devant la DB
* premier NoSQL réellement utilisé
* livejournal

## Pour aller plus loin

* cela dépend de nos besoins
* ceci est une remarque générale... il n'y a pas de solution miracle
        </section>

        <section data-background="img/night.png" data-background-repeat="repeat" data-background-size="640px">
          <div class="starwars" style="color: rgb(255, 255, 43);">
            <p class="fragment">... to step through ...</p>
            <p class="fragment">... to step through ...</p>
            <p class="fragment">... to step through ...</p>
          <!-- <section data-background="#007777">
            <h2>Slide Backgrounds</h2>
            <p>
              Set <code>data-background="#007777"</code> on a slide to change the full page background to the given color. All CSS color formats are supported.
            </p>
            <a href="#" class="image navigate-down">
              <img width="178" height="238" src="https://s3.amazonaws.com/hakim-static/reveal-js/arrow.png" alt="Down arrow">
            </a>
          </section>
          <section data-background="https://s3.amazonaws.com/hakim-static/reveal-js/arrow.png">
            <h2>Image Backgrounds</h2>
            <pre><code>&lt;section data-background="image.png"&gt;</code></pre>
          </section>
          <section data-background="https://s3.amazonaws.com/hakim-static/reveal-js/arrow.png" data-background-repeat="repeat" data-background-size="100px">
            <h2>Repeated Image Backgrounds</h2>
            <pre><code style="word-wrap: break-word;">&lt;section data-background="image.png" data-background-repeat="repeat" data-background-size="100px"&gt;</code></pre>
          </section> -->
        </section>

        <section>
#Bottleneck du stockage

## Arrive un moment, ou l'ajout de serveurs Webs cesse de régler le problème de la montée en charge

* le stockage est notre nouveau point de contension

## Première approche : cacher les données

* memcache devant la DB
* premier NoSQL réellement utilisé
* livejournal

## Pour aller plus loin

* cela dépend de nos besoins
* ceci est une remarque générale... il n'y a pas de solution miracle
        </section>

        <section>
#Le Web des CMS

## Sites avec beaucoup de lectures

* Solution : Réplication de la DB
* 1 master pour les écriture
* plusieurs slaves pour les lectures
* attention : gestion du retard
        </section>

        <section>
          <section>
            <h3>Mais au bout d'un moment...</h3>
            <p>la machine qui héberge la DB arrive à ses limites</p>
          </section>

          <section>
            <h3>Solution #1 : Partitionnemnent vertical</h3>

          </section>

          <section>
            <h3>Solution #2 : Partitionnement horizontal</h3>
            <p>aka Sharding</p>
            <br>
            <p>Avantage: facile ex nihilo</p>
            <p>Inconvénient: difficile en production</p>
            <br>
            <p>Solution chez Instagram : pré-sharding</p>
          </section>

          <section>
            <h3>Penser à d'autre technologies : Le NoSQL</h3>
            <p>...</p>
          </section>

          <section>
            Partie 3 : L'art de la distribution des données
===============================================

---
#Table de hachage persistante

* les informations sont ici stockées sur un nœud unique.
* Ce mode de stockage est donc efficace tant que le volume de données stockées et la charge de requêtes n’excèdent pas les capacités de la machine.
* En outre aucune tolérance aux pannes n’est ici admise puisque les données ne sont pas redondées.

---
#Sharding en distribution modulo

## On distribue les clés selon le modulo (du md5 de la clé par exemple)

![partition](images/partition.png "Partition")

* super simple
* mais on doit re-distribuer N-1/N data lors de l'ajout d'un N+1-ième noeud

---
#Sharding en hashing consistent

## un hashring est généré

![consistent hashing](images/consistenthashing.png "Consistent Hashing")

* plus complexe
* on ne doit re-distribuer que 1/N data lors de l'ajout d'un N+1-ième noeud

---
#Réplication sur N instances

## type simple  : 1 partition par instance

## type replica : M partitions par instances

![replication](images/replication.png "replication")

* on retrouve la notion de relachage de la consistence
* Dynamo (Amazon) et BigTable de google fonctionnent de cette manière
          </section>

        </section>

        <section>
          <h2>Le NoSQL</h2>
          <p>Ou, quand dénormaliser ses données ?</p>
        </section>




        <section>
          <h2>Fallacies of Distributed Computing</h2>
          <ul>
            <li>The network is reliable.</li>
            <li>Latency is zero.</li>
            <li>Bandwidth is infinite.</li>
            <li>The network is secure.</li>
            <li>Topology doesn't change.</li>
            <li>There is one administrator.</li>
            <li>Transport cost is zero.</li>
            <li>The network is homogeneous.</li>
          </ul>

        </section>


        <section>
          <h2>Some Case Studies</h2>
        </section>

        <section>
          <section>
            <h2>Case study #1</h2>

            <h3>Instagram</h3>
          </section>

          <section>
            <h3>30+ million users in less than 2 years</h3>
          </section>

          <section>
             <h3>25k signups in the ﬁrst day</h3>
            <p>everything is on ﬁre!</p>
          </section>

          <section>
            <blockquote>"scaling = replacing allcomponents of a car while driving it at 100mph"</blockquote>
          </section>
        </section>

        <section>
          <section>
            <h2>Case study #2</h2>

            <h3>Pinterest</h3>
          </section>

          <section>
            <h3>Premier étage (Mars 2010)</h3>
            <ul>
              <li>rackspace</li>
              <li>1 web</li>
              <li>1 DB</li>
            </ul>

          </section>

          <section>
            <h3>Deuxième étage (Janvier 2011)</h3>
            <ul>
              <li>AWS EC2 + S3 + Cloudfront</li>
              <li>1 nginx + 4 web engine</li>
              <li>1 mysql master + 1 slave</li>
              <li>1 task queue + 2 task processor</li>
              <li>1 mongodb</li>
            </ul>


          </section>

          <section>
            <h3>Troisième étage (Octobre 2012)</h3>
            <ul>
              <li>rackspace</li>
              <li>1 web</li>
              <li>1 DB</li>
            </ul>

          </section>
        </section>

        <section>
          <section>
            <h2>Case study #3</h2>

            <h3>Reddit</h3>
          </section>

          <section>
            <h3>Architecture</h3>
            Reddit architecture is straightforward. Users connect to a web tier which talks to an application tier. The application tier talks to memcache, Cassandra, and Postgres. Postgres uses a master-slave configuration. A batch system makes use of Cassandra and Postgres.
          </section>

          <section>
            EC2

Motivators for moving to EC2

Racking and stacking is not fun. Didn’t want to rent more cabinets and buy more servers.

Outgrew datacenter and in the early days growth was unpredictable.

Cost was beneficial for their use case of a team of 4 people. EC2 was 29% cheaper than their San Francisco datacenter.

EC2 is not a magic bullet. You suffer from higher network latency and noisy neighbors, so plan to work around it. Benefit is that you can grow as you need to.

Keep track of resource limits on EC2

All resources have per account limits.
Amazon doesn’t even know what some of their limits are.
Track limits and get them raised ahead of when you need them.
Catch exceptions to notice when limits have been reached.
          </section>


          <section>
            <h3>Petite Apparté : Différence Netflix</h3>
            In contrast Netflix use a service-oriented architecture where components talk to each other using REST APIs.

Advantages: Easier auto-scaling because just the service that is having the problem needs to scale; Easier capacity planning; Problems can be identified more easily because they are isolated behind REST calls; Effects of change are narrowed; More efficient local caching.

Disadvantages: Need multiple dev teams or devs to work on multiple services so you need more people; Need a common platform to prevent work duplication; Too much overhead for a small team just starting out.
          </section>
        </section>



        <section>
          <h1>THE END</h1>
        </section>

      </div>

    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.min.js"></script>

    <script>

      // Full list of configuration options available here:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        center: true,

        theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
        transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

        // Optional libraries used to extend on reveal.js
        dependencies: [
          { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
          { src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
          { src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
        ]
      });

    </script>

  </body>
</html>
